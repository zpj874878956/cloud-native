# 集群部署-kubeadm

## 主机准备

| 主机名  | 操作系统  | CPU  | MEM  | 角色要求 |
| ------- | --------- | ---- | ---- | -------- |
| master1 | CentOS7.6 | 2    | 2G   | master   |
| worker1 | CentOS7.6 | 2    | 2G   | worker   |
| worker2 | CentOS7.6 | 2    | 2G   | worker   |



| **主机操作系统** | **硬件配置** | **硬盘分区** | IP              |
| ---------------- | ------------ | ------------ | --------------- |
| CentOS7u6最小化  | 2C 2G 100G   | /boot、/     | 192.168.216.100 |
| CentOS7u6最小化  | 2C 2G 100G   | /boot、/     | 192.168.216.101 |
| CentOS7u6最小化  | 2C 2G 100G   | /boot、/     | 192.168.216.102 |

### 主机名

三台机器，分别对应设置

```shell
[root@XXX ~]# hostnamectl set-hostname XXX
主机名列表 
192.168.216.100 master1 
192.168.216.101 worker1 
192.168.216.102 worker2
```

### 主机IP地址

三台机器，分别对应设置

```shell
IP地址段根据自己主机实际情况进行配置
本次使用VMWare Workstation Pro虚拟机部署，需要注意网关设置。

[root@XXX ~]# cat /etc/sysconfig/network- scripts/ifcfg-ens33 
DEVICE=eth0 
TYPE=Ethernet 
ONBOOT=yes 
BOOTPROTO=static 
IPADDR=192.168.216.XXX 
NETMASK=255.255.255.0 
GATEWAY=192.168.216.2 
DNS1=119.29.29.29
```



### 主机名称解析

三台机器，同样设置

```shell
[root@XXX ~]# 
cat /etc/hosts 
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 
192.168.216.100 master1 
192.168.216.101 worker1 
192.168.216.102 worker2
```



### 主机安全配置

关闭firewalld

```shell
[root@XXX ~]# systemctl stop firewalld
[root@XXX ~]# systemctl disable firewalld 

#确认是否运行 
[root@XXX ~]# firewall-cmd --state 
not running
```

关闭selinux

```shell
[root@XXX ~]# sed -ri 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
```



### 主机时间同步

三台机器，同样设置

```shell
[root@XXX ~]# yum -y install ntpdate
[root@XXX ~]# crontab -l 
0 */1 * * * ntpdate time1.aliyun.com
```



### 永久关闭swap分区

使用kubeadm部署必须关闭swap分区，修改配置文件后需要重启操作系统。

```shell
[root@XXX ~]# cat /etc/fstab 
#
# /etc/fstab # Created by anaconda on Tue Mar 5 11:40:13 2019 
#
# Accessible filesystems, by reference, are maintained under '/dev/disk' 
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info 
#
/dev/mapper/centos-root / 
	xfs defaults 0 0
UUID=2791cef9-e7dd-40cb-917c-52f8bc061339 /boot xfs defaults 0 0

#/dev/mapper/centos-swap swap swap defaults 0 0
在swap文件系统对应的行，行首添加#表示注释。
```



### 添加网桥过滤

```shell
添加网桥过滤及地址转发 
[root@XXX ~]# cat /etc/sysctl.d/k8s.conf 
net.bridge.bridge-nf-call-ip6tables = 1 
net.bridge.bridge-nf-call-iptables = 1 
net.ipv4.ip_forward = 1 
vm.swappiness = 0 

加载br_netfilter模块 
[root@XXX ~]# modprobe br_netfilter

查看是否加载 
[root@XXX ~]# lsmod | grep br_netfilter 
br_netfilter 22256 0 bridge 151336 1 br_netfilter

加载网桥过滤配置文件 
[root@XXX ~]# sysctl -p 
/etc/sysctl.d/k8s.conf 
net.bridge.bridge-nf-call-ip6tables = 1 
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1 
vm.swappiness = 0
```



### 开启ipvs

安装ipset及ipvsadm

```shell
[root@XXX ~]# yum -y install ipset ipvsadm
```

在所有节点执行如下脚本

```shell
添加需要加载的模块 [root@XXX ~]# cat > 
/etc/sysconfig/modules/ipvs.modules <<EOF 
#!/bin/bash 
modprobe -- ip_vs 
modprobe -- ip_vs_rr 
modprobe -- ip_vs_wrr 
modprobe -- ip_vs_sh 
modprobe -- nf_conntrack_ipv4
EOF
```

```shell
授权、运行、检查是否加载 
[root@XXX ~]# chmod 755 
/etc/sysconfig/modules/ipvs.modules && bash 
/etc/sysconfig/modules/ipvs.modules && lsmod | grep -e ip_vs -e nf_conntrack_ipv4
```

```shell
检查是否加载
[root@XXX ~]# lsmod | grep -e ipvs -e nf_conntrack_ipv4
```



## 各节点安装docker-ce

### YUM源获取

> 建议使用清华镜像源，官方提供的镜像源由于网络速度原
>
> 因下载较慢

```powershell
[root@XXX ~]# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.tuna.tsinghua.edu.cn/docker- ce/linux/centos/docker-ce.repo
```

### 查看docker-ce版本

> 对版本进行排序查询

```powershell
[root@XXX ~]# yum list docker-ce.x86_64 -- showduplicates | sort -r
```

### 安装指定版本docker-ce

> 安装指定版本docker-ce，此版本不需要修改服务启动文件及iptables默认规则链策略。

> ```powershell
> [root@XXX ~]# yum -y install -- setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7
> ```

###  修改docker-ce服务配置文件

> 修改其目的是为了后续使用/etc/docker/daemon.json来进行更多配置。

```powershell
修改内容如下 [root@XXX ~]# cat /usr/lib/systemd/system/docker.service 
[Unit] 
...
[Service] 
... 
ExecStart=/usr/bin/dockerd #如果原文件此行后面 有-H选项，请删除-H(含)后面所有内容。
...
[Install]
...

注意：有些版本不需要修改，请注意观察

#在/etc/docker/daemon.json添加如下内容：
[root@localhost ~]# cat /etc/docker/daemon.json 
{ "exec-opts": ["native.cgroupdriver=systemd"] }
```



## **部署软件及配置**

### 软件安装

> 所有k8s集群节点均需安装，默认YUM源是谷歌，可以使
>
> 用阿里云YUM

| 需求 | kubeadm                                | kubelet                                                      | kubectl                          | docker-ce |
| ---- | -------------------------------------- | ------------------------------------------------------------ | -------------------------------- | --------- |
| 值   | 初始化集群、管理集群等，版本为：1.17.2 | 用于接收api-server指令，对pod生命周期进行管理，版本为：1.17.2 | 集群命令行管理工具，版本为1.17.2 | 18.06.3   |

* 谷歌YUM源

```powershell
[kubernetes] 
name=Kubernetes 
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 
enabled=1 
gpgcheck=1 
repo_gpgcheck=1 
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
```

* 阿里云YUM源

```powershell
[kubernetes] 
name=Kubernetes 
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ 
enabled=1 
gpgcheck=1 
repo_gpgcheck=1 
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
```

* 安装指定版本 kubeadm kubelet kubectl

```powershell
[root@XXX ~]# yum list kubeadm.x86_64 -- showduplicates | sort -r 
[root@XXX ~]# yum -y install -- setopt=obsoletes=0 kubeadm-1.17.2-0 kubelet- 1.17.2-0 kubectl-1.17.2-0
```



### 软件设置

> 主要配置kubelet，如果不配置可能会导致k8s集群无法启动。

```powershell
为了实现docker使用的cgroupdriver与kubelet使用的 cgroup的一致性，建议修改如下文件内容。 
[root@XXX ~]# vim /etc/sysconfig/kubelet 
KUBELET_EXTRA_ARGS="--cgroup-driver=systemd"
```

```powershell
设置为开机自启动即可，由于没有生成配置文件，集群初始化 后自动启动 
[root@XXX ~]# systemctl enable kubelet
```



## k8s集群容器镜像准备

> 由于使用kubeadm部署集群，集群所有核心组件均以Pod运行，需要为主机准备镜像，不同角色主机准备不同
>
> 镜像，建议使用科学上网方式下载镜像

### Master主机镜像

```powershell
查看集群使用的容器镜像 
[root@master1 ~]# kubeadm config images list 
k8s.gcr.io/kube-apiserver:v1.17.2 
k8s.gcr.io/kube-controller-manager:v1.17.2 
k8s.gcr.io/kube-scheduler:v1.17.2 
k8s.gcr.io/kube-proxy:v1.17.2 k8s.gcr.io/pause:3.1 
k8s.gcr.io/etcd:3.4.3-0 
k8s.gcr.io/coredns:1.6.5

列出镜像列表到文件中，便于下载使用。 
[root@master1 ~]# kubeadm config images list >> image.list

查看已列出镜像文件列表 
[root@master1 ~]# cat image.list

编写镜像下载脚本 
[root@master1 ~]# cat image.pull 
#!/bin/bash 
img_list=' k8s.gcr.io/kube-apiserver:v1.17.2 
k8s.gcr.io/kube-controller-manager:v1.17.2 
k8s.gcr.io/kube-scheduler:v1.17.2 
k8s.gcr.io/kube-proxy:v1.17.2 
k8s.gcr.io/pause:3.1 
k8s.gcr.io/etcd:3.4.3-0 
k8s.gcr.io/coredns:1.6.5
'
for img in $img_list
do
	docker pull $img
done

执镜像下载脚本 
[root@master1 ~]# sh image.pull

查看已下载镜像
[root@master1 ~]# docker images
```

### Worker主机镜像

```powershell
保存镜像为tar
[root@master1 ~]# docker save -o kube- proxy.tar k8s.gcr.io/kube-proxy:v1.17.2
[root@master1 ~]# docker save -o pause.tar k8s.gcr.io/pause:3.1
[root@master1 ~]# ls kube-proxy.tar pause.tar

复制tar到worker节点 
[root@master1 ~]# scp kube-proxy.tar pause.tar work1:/root

[root@master1 ~]# scp kube-proxy.tar pause.tar work2:/root

在worker节点导入镜像
[root@work1 ~]# ls 
kube-proxy.tar pause.tar
[root@work1 ~]# docker load -i kube- proxy.tar
[root@work1 ~]# docker load -i pause.tar

[root@work2 ~]# ls 
kube-proxy.tar pause.tar
[root@work2 ~]# docker load -i kube- proxy.tar
[root@work2 ~]# docker load -i pause.tar
```



## k8s集群初始化

### master节点

```powershell
[root@master1 ~]# kubeadm init --kubernetes-version=v1.17.2 --pod-network-cidr=172.16.0.0/16 --apiserver-advertise-address=192.168.216.100

# 192.168.216.100 是当前主机IP

初始化过程中导出结果
...... 
Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

	mkdir -p $HOME/.kube
	sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
	sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml"
with one of the options listed at:https://kubernetes.io/docs/concepts/cluste r-administration/addons/

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 192.168.216.100:6443 --token m0rpym.522tija0299geb8h \ --discovery-token-ca-cert-hash sha256:cef7351d9fefc67868f22aa3122165dd01f63 e95870d2fb22197ee66c61b18d6
```



### 准备集群管理文件

```powershell
[root@master1 ~]# mkdir .kube 
[root@master1 ~]# cp -i /etc/kubernetes/admin.conf .kube/config 
[root@master1 ~]# chown $(id -u):$(id -g) .kube/config
```



### 网络插件使用

#### calico镜像准备

> 三台主机都要操作

```powershell
[root@master1 calico39]# ls 
calico-cni.tar calico.yml pod2daemon-flexvol.tar calico-node.tar kube-controllers.tar

[root@master1 calico39]# docker load -i calico-cni.tar

[root@master1 calico39]# docker load -i calico-node.tar

[root@master1 calico39]# docker load -i pod2daemon-flexvol.tar

[root@master1 calico39]# docker load -i kube-controllers.tar

[root@master1 calico39]# docker images
```



#### 修改calico资源清单文件

```powershell
1) 由于calico自身网络发现机制有问题，因为需要修改 calico使用的物理网卡，添加607及608行
[root@master1 calico39]# vim calico.yml

602 - name: CLUSTER_TYPE
603 value: "k8s,bgp"
604 # Auto-detect the BGP IP address.
605 - name: IP
606 value: "autodetect"
607 - name: IP_AUTODETECTION_METHOD
608 value: "interface=ens.*"

说明：ens.，这个值在服务器上if a查看。

2) 修改为初始化时设置的pod-network-cidr
619 - name: CALICO_IPV4POOL_CIDR
620 value: "172.16.0.0/16"
```

#### 应用calico资源清单文件

> 在应用caclico资源清单文件之前，需要把calico所有的镜像导入到node节点中。

```powershell
[root@master1 calico39]# kubectl apply -f calico.yml

输出结果
configmap/calico-config created customresourcedefinition.apiextensions.k8s.i o/felixconfigurations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/ipamblocks.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/blockaffinities.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/ipamhandles.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/ipamconfigs.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/bgppeers.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/bgpconfigurations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/ippools.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/hostendpoints.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/clusterinformations.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/globalnetworkpolicies.crd.projectcalico.or g created customresourcedefinition.apiextensions.k8s.i o/globalnetworksets.crd.projectcalico.org created
customresourcedefinition.apiextensions.k8s.i o/networkpolicies.crd.projectcalico.org created customresourcedefinition.apiextensions.k8s.i o/networksets.crd.projectcalico.org created clusterrole.rbac.authorization.k8s.io/calico -kube-controllers created clusterrolebinding.rbac.authorization.k8s.io /calico-kube-controllers created clusterrole.rbac.authorization.k8s.io/calico -node created clusterrolebinding.rbac.authorization.k8s.io /calico-node created daemonset.apps/calico-node created serviceaccount/calico-node created deployment.apps/calico-kube-controllers created serviceaccount/calico-kube-controllers created
```



### 添加工作节点到集群

```powershell
[root@work1 ~]# kubeadm join 192.168.122.100:6443 --token m0rpym.522tija0299geb8h \ 
--discovery-token-ca-cert-hash sha256:cef7351d9fefc67868f22aa3122165dd01f63e 95870d2fb22197ee66c61b18d6
......

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.

[root@work2 ~]# kubeadm join 192.168.122.100:6443 --token m0rpym.522tija0299geb8h \ 
--discovery-token-ca-cert-hash sha256:cef7351d9fefc67868f22aa3122165dd01f63e 95870d2fb22197ee66c61b18d6

......

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.
```



## 验证k8s集群可用性方法

```powershell
查看节点状态
[root@master1 ~]# kubectl get nodes

查看集群健康状态
[root@master1 ~]# kubectl get cs
或
[root@master1 ~]# kubectl cluster-info
Kubernetes master is running at https://192.168.122.11:6443 
KubeDNS is running at https://192.168.122.11:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy

To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
```



# k8s集群客户端工具kubectl

## kubectl帮助方法

```powershell
检查kubectl是否安装
[root@master1 ~]# rpm -qa | grep kubectl

获取kubectl帮助方法 
[root@master1 ~]# kubectl --help
```

## kubectl子命令使用分类

 ![image-20210422105009050](images/image-20210422105009050.png)

 ![image-20210422105032732](images/image-20210422105032732.png)



## 使用kubectl命令必要环境

> 在worker节点如何使用kubectl命令管理k8s集群

```powershell
准备集群管理配置文件 
[root@work1 ~]# mkdir .kube
[root@work1 ~]# scp master1:/root/.kube/config .kube/

使用命令验证 
[root@work1 ~]# kubectl get nodes
```



# k8s集群资源清单(YAML)文件书写方法

## YAML文件书写格式

### YAML介绍

YAML ：仍是一种标记语言。

为了强调这种语言以数据做为中心，而不是以标记语言为重点。

YAML是一个可读性高，用来表达数据序列的格式。



### 基本语法

使用空格做为缩进

缩进的空格数目不重要，只要相同层级的元素左侧对齐即可

低版本缩进时不允许使用Tab键，只允许使用空格

使用#标识注释，从这个字符一直到行尾，都会被解释器忽略



### YAML支持的数据结构

* 对象

    键值对的集合

    又称为映射(mapping) / 哈希（hashes） / 字典

    （dictionary）

```powershell
对象类型：对象的一组键值对，使用冒号结构表示
name: Tom 
age: 18

Yaml 也允许另一种写法，将所有键值对写成一个行内对象
hash: { name: Tom, age: 18 }

```

* 数组：

    一组按次序排列的值

    又称为序列（sequence） / 列表 （list）

```powershell
数组类型：一组连词线开头的行，构成一个数组

People 
- Tom 
- Jack

数组也可以采用行内表示法
People: [Tom, Jack]
```

* 纯量（scalars）：

    单个的、不可再分的值

```powershell
纯量：纯量是最基本的、不可再分的值。以下数据类型都属于 纯量

数值直接以字面量的形式表示
number: 12.30

布尔值用true和false表示
isSet: true

null用 ~ 表示 
parent: ~

时间采用 ISO8601 格式 
iso8601: 2001-12-14t21:59:43.10-05:00

日期采用复合 iso8601 格式的年、月、日表示 
date: 1976-07-31

YAML 允许使用两个感叹号，强制转换数据类型
e: !!str 123
f: !!str true

字符串默认不使用引号表示

str: 这是一行字符串

如果字符串之中包含空格或特殊字符，需要放在引号之中

str: '内容： 字符串'

单引号和双引号都可以使用，双引号不会对特殊字符转义 
s1: '内容\n字符串' 
s2: "内容\n字符串"

单引号之中如果还有单引号，必须连续使用两个单引号转义 
str: 'labor''s day'

字符串可以写成多行，从第二行开始，必须有一个单空格缩 进。换行符会被转为 空格 
str: 这是一段 
	多行
	字符串
	
多行字符串可以使用|保留换行符，也可以使用>折叠换行
this: | 
Foo 
Bar

that 
Foo 
Bar


```

## **资源清单描述方法**

> 在k8s中，一般使用YAML格式的文件来创建符合我们预期期
>
> 望的pod,这样的YAML文件称为资源清单。

### **常用字段**

| 参数名                                      | 字段类型 | 说明                                                         |
| ------------------------------------------- | -------- | ------------------------------------------------------------ |
| version                                     | String   | 这里是指的是K8S API的版本，目前基本上是v1，可以用kubectl api-versions命令查询 |
| kind                                        | String   | 这里指的是yam文件定义的资源类型和角色，比如:Pod              |
| metadata                                    | Object   | 元数据对象，固定值就写metadata                               |
| metadata.name                               | String   | 元数据对象的名字，这里由我们编写，比如命名Pod的名字          |
| metadata.namespace                          | String   | 元数据对象的命名空间，由我们自身定义                         |
| Spec                                        | Object   | 详细定义对象，固定值就写Spec                                 |
| spec. containers[]                          | list     | 这里是Spec对象的容器列表定义，是个列表                       |
| spec containers [].name                     | String   | 这里定义容器的名字                                           |
| spec.containers [].image                    | String   | 这里定义要用到的镜像名称                                     |
| spec.containers [].imagePullPolicy          | String   | 定义镜像拉取策略，有Always、 Never、 IfNotPresent三个值可选(1) Always:意思是每次都尝试重新拉取镜像(2) Never:表示仅使用本地镜像(3) IfNotPresent:如果本地有镜像就使用本地镜像，没有就拉取在线镜像。上面三个值都没设置的话，默认是Always。 |
| spec containers [].command[]                | List     | 指定容器启动命令，因为是数组可以指定多个。不指定则使用镜像打包时使用的启动命令。 |
| spec.containers [].args                     | List     | 指定容器启动命令参数，因为是数组可以指定多个.                |
| spec.containers [].workDir                  | String   | 指定容器的工作目录                                           |
| spec.containers[]. volumeMounts[]           | List     | 指定容器内部的存储卷配置                                     |
| spec.containers[]. volumeMounts[].name      | String   | 指定可以被容器挂戴的存储卷的名称                             |
| spec.containers[]. mountPath                | String   | 指定可以被容器捱戴的存储卷的路径                             |
| spec.containers[]. volumeMounts[].readOnly  | String   | 设置存储卷路径的读写模式，ture或者false，默认为读写模式      |
| spec.containers [].ports[]                  | String   | 指症容器需要用到的端口列表                                   |
| spec.containers [].ports[].name             | String   | 指定端口名称                                                 |
| spec.containers [].ports[].containerPort    | String   | 指定容器需要监听的端口号                                     |
| spec.containers [].ports[].hostPort         | String   | 指定容所在主机需要监听的端口号，默认跟上面containerPort相同，注意设置了 hostPort同一台主机无法启动该容器的相同副本(因为主机的端口号不能相同，这样会冲突) |
| spec.containers [].ports[].protocol         | String   | 指定端口协议，支持TCP和 UDP，默认值为TCP                     |
| spec.containers [].env[]                    | List     | 指定容器运行前需设的环境变量列表                             |
| spec.containers [].env[].name               | String   | 指定环境变量名称                                             |
| spec.containers [].env[].value              | String   | 指定环境变量值                                               |
| spec.containers[].resources                 | Object   | 指定资源 限制和资源请求的值（这里开始就是设置容器的资源上限） |
| spec.containers[].resources.limits          | Object   | 指定设置容器运行时资源的运行上限                             |
| spec.containers[].resources.limits.cpu      | String   | 指定CPU限制，单位为core数，将用于docker run -- cpu- shares参数 |
| spec.containers[].resources.limits.memory   | String   | 指定MEM内存的限制，单位为MiB、GiB                            |
| spec.containers[].resources.requests        | Object   | 指定容器启动和调度时的限制设置                               |
| spec.containers[].resources.requests.cpu    | String   | CPU请求，单位为core数，容器启动时初始化可用数量              |
| spec.containers[].resources.requests.memory | String   | 内存请求，单位为MiB、GiB，容器启动时初始化可用数量           |
| sepc.restartPolicy                          | String   | 定义Pod的重启策略，可选值为Always、 OnFailure,默认值为Always。 1.Always:Pod一旦终止运行，则无论容器时如何终止的，kubelet服务都将重启它。2.OnFailure:只 有Pod以非零退出码终止时，kubelet才会重启该容器。如果容器正常结束（退出码为0），则kubelet将不会重启它。3.Never:Pod终止后，kubelet将退出码报告给Master,不会重启该Pod。 |
| spec.nodeSelector                           | Object   | 定义Node的 Label过滤标签，以key:value格式指定。              |
| spec.imagePullSecrets                       | Object   | 定义pull镜像时使用secret名称，以name:secretkey格式指定。     |
| spec.hostNetwork                            | Boolean  | 定义是否使用主机网络模式，默认值为false。设置true表示使用宿主机网络，不使用docker网桥，同时设置了true将无法在同一台宿主机上启动第二个副本。 |



### **举例说明**

创建一个namespace

```yaml
apiVersion: v1 
kind: Namespace 
metadata: 
	name: test
```

创建一个pod

```yaml
apiVersion: v1
kind: Pod
metadata:
	name: pod1
spec: 
	containers:
	- name: nginx-containers
	  image: nginx:latest
```



# k8s集群NameSpace(命名空间)
## NameSpace介绍

命名空间

作用：多租户情况下，实现资源隔离

属于逻辑隔离

属于管理边界

不属于网络边界

可以针对每个namespace做资源配额



## 查看NameSpace

```powershell
命令
[root@master1 ~]# kubectl get namespace
```

```powershell
输出
NAME 				STATUS 		AGE 
default 			Active 		16h 
kube-node-lease 	 Active 	 16h 
kube-public 		Active 		16h 
kube-system 		Active 		16h
```

```powershell
说明
default 用户创建的pod默认在此命名空间 
kube-public 所有用户均可以访问，包括未认证用户 
kube-node-lease kubernetes集群节点租约状态 
v1.13加入 
kube-system kubernetes集群在使用
```

## 创建NameSpace

### 通过kubectl命令行创建

```powershell
命令
[root@master1 ~]# kubectl create namespace
test
```

```powershell
输出
namespace/test created
```

```powershell
命令
[root@master1 ~]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 16h 
kube-node-lease Active 16h 
kube-public Active 16h 
kube-system Active 16h 
test Active 16s 已经创建
```



### 通过kubectl命令应用资源清单文件创建

```powershell
准备资源清单文件
[root@master1 yamldir]# cat 01-create-ns.yaml
apiVersion: v1
kind: Namespace
metadata:
	name: demons1
```

```powershell
命令
应用资源清单文件
[root@master1 yamldir]# kubectl apply -f 01- create-ns.yaml
```

```powershell
命令
验证是否创建成功
[root@master1 yamldir]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 16h 
demons1 Active 30s 
kube-node-lease Active 16h 
kube-public Active 16h 
kube-system Active 16h 
test Active 13m 已创建
```

## 删除NameSpace

> 删除命名空间时，命名空间中包含的所有资源对象同时被删除。

### 通过kubectl命令行删除

```powershell
命令
查看namespace
[root@master1 yamldir]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 16h 
demons1 Active 7m15s 
kube-node-lease Active 16h 
kube-public Active 16h 
kube-system Active 16h 
test Active 19m 确认存在
```

```powershell
命令
删除namespace 
[root@master1 yamldir]# kubectl delete namespace test
```

```powershell
输出
namespace "test" deleted
```

```powershell
命令
查看现有NameSpace，确认是否删除
[root@master1 yamldir]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 16h 
demons1 Active 7m39s 
kube-node-lease Active 16h 
kube-public Active 16h 
kube-system Active 16h
```

### 通过kubectl命令应用资源清单文件删除
```powershell
命令
查看namespace
[root@master1 yamldir]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 16h 
demons1 Active 7m39s 确认存在 
kube-node-lease Active 16h 
kube-public Active 16h 
kube-system Active 16h
```



```powershell
查看namespace资源清单文件
[root@master1 yamldir]# cat 01-create-ns.yaml
apiVersion: v1
kind: Namespace
metadata:
	name: demons1
```

```powershell
命令
通过namespace资源清单文件删除
[root@master1 yamldir]# kubectl delete -f 01- create-ns.yaml

```

```powershell
输出
namespace "demons1" deleted
```

```powershell
命令
确认是否被删除
[root@master1 yamldir]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 16h 
kube-node-lease Active 16h 
kube-public Active 16h 
kube-system Active 16h
```



# k8s集群核心概念 Pod

## pod介绍

Pod是kubernetes集群能够调度的最小单元

Pod是容器的封装



## 查看Pod

```powershell
命令及输出 
查看default命名空间中的Pod
[root@master1 ~]# kubectl get pod
No resources found.
或
[root@master1 ~]# kubectl get pods
No resources found.
或
[root@master1 ~]# kubectl get pods --namespace default
No resources found.
或
[root@master1 ~]# kubectl get pod --namespace default
No resources found.
```

```powershell
命令
查看kube-system命名空间中的Pod
[root@master1 ~]# kubectl get namespace
```

```powershell
输出
NAME STATUS AGE 
default Active 17h 
kube-node-lease Active 17h 
kube-public Active 17h 
kube-system Active 17h 确认有此命名空间
```

```powershell
命令
[root@master1 ~]# kubectl get pod -n kube- system
```

```powershell
输出
NAME READY STATUS RESTARTS AGE 
calico-node-896hj 1/2 Running 0 17h calico-node-q4w7q 2/2 Running 0 17h calico-node-qzws6 1/2 Running 0 17h calico-typha-7d87d68466-5mdw4 1/1 Running 0 17h coredns-5c98db65d4-9l4tp 1/1 Running 0 17h coredns-5c98db65d4-sqxj7 1/1 Running 0 17h etcd-master1 1/1 Running 0 17h kube-apiserver-master1 1/1 Running 0 17h kube-controller-manager-master1 1/1 Running 0 17h kube-proxy-4sgmb 1/1 Running 0 17h kube-proxy-crmq2 1/1 Running 0 17h kube-proxy-sqhp4 1/1 Running 0 17h
```

## 创建Pod

> 由于网络原因，建议提前准备好容器镜像。本次使用nginx:latest容器镜像。

### 编写用于创建Pod资源清单文件

```powershell
[root@master1 yamldir]# cat 02-create-pod.yaml
apiVersion: v1
kind: Pod
metadata:
	name: pod1
spec:
	containers:
	- name: ngninx-pod
	  image: nginx:latest
	  ports:
	  - name: nginxport
	  	containerPort: 80
```



### 应用用于创建Pod资源清单文件

```powershell
命令
[root@master1 yamldir]# kubectl apply -f 02-create-pod.yaml
```

```powershell
输出
pod/pod1 created
```



### 验证Pod是否被创建

```powershell
命令
查看已创建pod
[root@master1 yamldir]# kubectl get pods
```

```powershell
输出
NAME READY STATUS RESTARTS AGE 
pod1 1/1 Running 0 88s
```

```powershell
命令
通过指定默认命名空间查看已创建pod 
[root@master1 yamldir]# kubectl get pods -n default
```

```powershell
输出
NAME READY STATUS RESTARTS AGE 
pod1 1/1 Running 0 2m43s
```

```powershell
命令
查看pod更加详细信息 
[root@master1 yamldir]# kubectl get pods -o wide
```

```powershell
输出
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GAT 
pod1 1/1 Running 0 9m5s 172.16.1.2 node2 <none> <none>
```



## Prod访问

```powershell
命令
[root@master1 ~]# curl http://172.16.1.2
```

```powershell
输出
<!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body {width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required. </p> <p>For online documentation and support please refer to <a href="http://nginx.org/">nginx.org</a>. <br/> Commercial support is available at <a href="http://nginx.com/">nginx.com</a>. </p> <p><em>Thank you for using nginx.</em></p> </body></html>
```



## 删除Prod

> 可通过命令行删除，也可通过资源清单(YAML)文件删除。

### kubectl命令行删除

```powershell
命令
[root@master1 ~]# kubectl delete pods pod1
```

```powershell
输出
pod "pod1" deleted
```



### 通过kubectl使用Pod资源清单文件删除

```powershell
命令
[root@master1 yamldir]# kubectl delete -f 02-create-pod.yaml
```

```powershell
输出
pod "pod1" deleted
```



# k8s集群核心概念 Controller(控制器)

## Controller介绍

控制器

用于对应用运行的资源对象进行监控

当Pod出现问题时，会把Pod重新拉起，以达到用户的期望状态



## Controller分类

常见Pod控制器：

| 控制器名称  | 作用                                                         |
| ----------- | ------------------------------------------------------------ |
| Deployment  | 声明式更新控制器，用于发布无状态应用                         |
| ReplicaSet  | 副本集控制器，用于对Pod进行副本规模扩大或剪裁                |
| StatefulSet | 有状态副本集，用于发布有状态应用                             |
| DaemonSet   | 在k8s集群每一个Node上运行一个副本，用于发布监控或日志收集类等应用 |
| Job         | 运行一次性作业任务                                           |
| CronJob     | 运行周期性作业任务                                           |
|             |                                                              |

## Deployment控制器介绍

* 具有上线部署、滚动升级、创建副本、回滚到以前某一版本（成功/ 稳定）等功能

* Deployment包含ReplicaSet，除非需要自定义升级功能

    或者根本不需要升级Pod，否则还是建议使用

    Deployment而不直接使用Replica Set 。



## 创建Deployment控制器类型应用

### 通过kubectl命令行创建

```powershell
命令
[root@master1 ~]# kubectl run nginx-app --image=nginx:latest --image-pull-policy=IfNotPresent --replicas=2
```

```powershell
输出
deployment.apps/nginx-app created
```



```powershell
说明
nginx-app 是deployment控制器类型的应用名称 
nginx:latest 是应用运行的Pod中的Container所使用的 镜像
IfNotPresent 是Container容器镜像下载策略，如果本 地有镜像，使用本地，如果本地没有镜像，下载镜像 
--replicas=2 是指应用运行的Pod共计2个副本，这是用 户的期望值，Deployment控制器中的ReplicaSet控制器会 一直监控此应用运行的Pod副本状态，如果数量达不到用户期 望，就会重新拉起一个新的Pod，会让Pod数量一直维持在用 户期望值数量。
```

```powershell
命令
查看Deployment控制器类型应用 
[root@master1 ~]# kubectl get deployment.apps
```

```powershell
输出
NAME READY UP-TO-DATE AVAILABLE AGE 
nginx-app 2/2 2 2 2m46s
```

```powershell
命令
查看ReplicaSet控制器类型 
[root@master1 ~]# kubectl get replicaset
```

```powershell
输出
NAME DESIRED CURRENT READY AGE 
nginx-app-84c4bb6478 2 2 2 3m14s
```

```powershell
命令
查看Pod状态 
[root@master1 ~]# kubectl get pods
```

```powershell
输出
NAME READY STATUS RESTARTS AGE 
nginx-app-84c4bb6478-c72fj 1/1 Running 0 3m37s 
nginx-app-84c4bb6478-cxjqn 1/1 Running 0 3m37s
```

```powershell
命令
查看Pod状态，显示更宽泛信息 
[root@master1 ~]# kubectl get pods -o wide
```

```powershell
输出
NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES nginx-app-84c4bb6478-c72fj 1/1 Running 0 5m52s 172.16.215.5 work1 <none> <none> nginx-app-84c4bb6478-cxjqn 1/1 Running 0 5m52s 172.16.123.56 work2 <none> <none>
```

```powershell
命令
访问Pod 
[root@master1 ~]# curl http://172.16.215.5 
[root@master1 ~]# curl http://172.16.123.56
```

```powershell
输出
访问Pod输出web页面信息 
<!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body {width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required. </p> <p>For online documentation and support please refer to<a href="http://nginx.org/">nginx.org</a>. <br/> Commercial support is available at <a href="http://nginx.com/">nginx.com</a>. </p> <p><em>Thank you for using nginx.</em></p> </body> </html>
```



### 通过资源清单文件创建

#### 编写用于创建Deployment控制器类型应用资源清单

```powershell
[root@master1 ~]# cat 03-creat-deployment- app.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-apps
    labels:
	  app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
        - name: nginxapp
          image: nginx:latest
          imagePullPolicy: IfNotPresent
          ports:
          - containerPort: 80 
```



#### 应用创建Deployment控制器类型应用资源清单

```powershell
命令
[root@master1 ~]# kubectl apply -f 03-creat- deployment-app.yaml
```

```powershell
输出
deployment.apps/nginx-apps created
```

#### 验证资源清单应用后结果

```powershell
命令
查看Deployment控制器类型应用 
[root@master1 ~]# kubectl get deployment.apps

```

```powershell
输出
NAME READY UP-TO-DATE AVAILABLE AGE 
nginx-apps 1/1 1 1 78s
```

```powershell
命令
查看ReplicaSet控制器类型应用 
[root@master1 ~]# kubectl get replicaset.apps
```

```powershell
命令
查看Pod状态 
[root@master1 ~]# kubectl get pods
```

```powershell
输出
NAME READY STATUS RESTARTS AGE 
nginx-apps-66dcfbcd96-c8bjv 1/1 Running 0 2m9s
```



## 删除Deployment控制器类型应用

> 带有控制器类型的Pod不能随便删除，如果必须删除，请删除控制器类型的应用名称。

### 通过kubectl命令行删除

```powershell
命令
[root@master1 ~]# kubectl get deployment.apps
```

```powershell
输出
NAME READY UP-TO-DATE AVAILABLE AGE 
nginx-app 2/2 2 2 20m
```

```powershell
命令
[root@master1 ~]# kubectl delete deployment.apps nginx-app
```

```powershell
输出
deployment.apps "nginx-app" deleted
```

### 通过kubectl应用资源清单文件删除

```powershell
命令
[root@master1 ~]# kubectl get deployment.apps
```

```powershell
输出
NAME READY UP-TO-DATE AVAILABLE AGE 
nginx-apps 1/1 1 1 8m15s
```

```powershell
命令
[root@master1 ~]# kubectl delete -f 03-creat-deployment-app.yaml
```

```powershell
输出
deployment.apps "nginx-apps" deleted
```



# k8s集群核心概念 Service

## Service介绍

不是实体服务

是一条iptables或ipvs的转发规则



## Service作用

通过Service为pod客户端提供访问pod方法，即客户端访问pod入口

Service通过Pod标签与Pod进行关联

 ![image-20210422154649366](images/image-20210422154649366.png)



## Service类型

* ClusterIP

    默认，分配一个集群内部可以访问的虚拟IP

* NodePort

    在每个Node上分配一个端口作为外部访问入口

* LoadBalancer

    工作在特定的Cloud Provider上，例如Google Cloud，AWS，OpenStack

* ExternalName

    表示把集群外部的服务引入到集群内部中来，即实现了

    集群内部pod和集群外部的服务进行通信

## Service参数

* port 访问service使用的端口

* targetPort Pod中容器端口

* NodePort 通过Node实现外网用户访问k8s集群内service

    (30000-32767)

## Service创建

Service的创建在工作中有两种方式，一是命令行创建，二是通过资源清单文件YAML文件创建

### 通过命令行创建

默认创建Service为ClusterIP类型



#### 创建Deployment类型应用

```powershell
命令
[root@master1 ~]# kubectl run nginx-app -- image=nginx:latest --image-pull-policy=IfNotPresent --replicas=1
```

```powershell
输出
deployment.apps/nginx-app created
```



#### 验证Deployment类型应用创建情况

```powershell
命令
[root@master1 ~]# kubectl get deployment.apps
```

```powershell
输出
NAME READY UP-TO-DATE AVAILABLE AGE 
nginx-app 1/1 1 1 71s
```



#### 创建Service与Deployment类型应用关联

```powershell
命令
创建service 
[root@master1 ~]# kubectl expose deployment.apps nginx-app --type=ClusterIP -- target-port=80 --port=80
```

```powershell
输出
service/nginx-app exposed
```



```powershell
说明
expose 创建service 
deployment.apps 控制器类型 
nginx-app 应用名称，也是service名称 
--type=ClusterIP 指定service类型 
--target-port=80 指定Pod中容器端口 
--port=80 指定service端口
```



#### 访问Service以实现访问Pod目的

```powershell
命令
查看Service创建情况
[root@master1 ~]# kubectl get service

```

```powershell
输出
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE 
nginx-app ClusterIP 10.109.21.171 <none> 80/TCP 5m15s
```

```powershell
命令
访问Service 
[root@master1 ~]# curl http://10.109.21.171
```

```powershell
输出
<!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body {width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed andworking. Further configuration is required. </p> <p>For online documentation and support please refer to <a href="http://nginx.org/">nginx.org</a>. <br/> Commercial support is available at <a href="http://nginx.com/">nginx.com</a>. </p> <p><em>Thank you for using nginx.</em></p> </body> </html>
```



### 通过资源清单YAML文件创建

#### 编写用于创建Service资源清单文件

```powershell
[root@master1 ~]# cat create-deployment-service-clusterip.yaml
---
apiVersion: apps/v1
kind: Deployment 
metadata:
  name: nginx-apps
  labels:
    app: nginx
spec: 
  replicas: 1 
  selector: 
    matchLabels: 
      app: nginx
  template: 
    metadata: 
      labels: 
        app: nginx
    spec:
      containers:
      - name: nginxapps
        image: nginx:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service 
metadata: 
  name: nginx-apps
spec:
  type: ClusterIP
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

#### 应用用于创建Service资源清单文件

```powershell
命令
应用create-deployment-service-clusterip.yaml 
[root@master1 ~]# kubectl apply -f create-deployment-service-clusterip.yaml
```

```powershell
输出
deployment.apps/nginx-apps created 
service/nginx-apps created
```



#### 验证资源对象创建结果

```powershell
命令
查看deployment.apps 
[root@master1 ~]# kubectl get deployment.apps
```

```powershell
输出
NAME READY UP-TO-DATE AVAILABLE AGE 
nginx-apps 1/1 1 1 48s
```

```powershell
命令
[root@master1 ~]# kubectl get service
```

```powershell
输出
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE 
nginx-apps ClusterIP 10.105.7.229 <none> 80/TCP 2m22s
```

```powershell
命令
[root@master1 ~]# curl http://10.105.7.229
```

```powershell
输出
<!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body {width: 35em;margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required. </p> <p>For online documentation and support please refer to <a href="http://nginx.org/">nginx.org</a>. <br/> Commercial support is available at <a href="http://nginx.com/">nginx.com</a>. </p> <p><em>Thank you for using nginx.</em></p> </body> </html>
```



### 基于资源清单YAML文件创建NodePort类型Service

#### 编写资源清单文件

```powershell
[root@master1 ~]# cat create-deployment-service-nodeport.yaml
---
apiVersion: apps/v1 
kind: Deployment 
metadata:
  name: nginx-app-nodeport
  labels:
    app: nginx-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-app
  template:
    metadata:
      labels:
        app: nginx-app4
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-app
spec:
  selector:
    app: nginx-app
  type: NodePort
  ports:
  - protocol: TCP
    nodePort: 30001
    port: 80
    targetPort: 80
    
```



#### 应用资源清单文件

```powershell
命令
应用create-deployment-service-nodeport.yaml 
[root@master1 ~]# kubectl apply -f create-deployment-service-nodeport.yaml
```



```powershell
输出
deployment.apps/nginx-app-nodeport created 
service/nginx-app created
```



#### 验证资源对象创建情况

```powershell
命令
查看service创建 
[root@master1 ~]# kubectl get service
```

```powershell
输出
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE 
nginx-app NodePort 10.98.196.211 <none> 80:30001/TCP 26s
```

```powershell
命令
查看k8s集群所有主机30001端口侦听状态 
[root@XXX ~]# ss -anput | grep ":30001"
```

```powershell
输出
tcp LISTEN 0 128 [::]:30001 [::]:* users: (("kube-proxy",pid=4164,fd=21))
```



#### 在k8s集群外访问Service

> 在物理机浏览器中访问即可验证。

 ![image-20210422164210623](images/image-20210422164210623.png)



## 删除Service

### 通过命令行删除

```powershell
命令
查看servie 
[root@master1 ~]# kubectl get service
```

```powershell
输出
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE 
nginx-app ClusterIP 10.109.21.171 <none> 80/TCP 18m
```

```powershell
命令删除service 
[root@master1 ~]# kubectl delete service nginx-app
```

```powershell
输出
service "nginx-app" deleted
```



### 通过资源清单YAML文件删除

```powershell
命令
应用create-deployment-service-clusterip.yaml 
[root@master1 ~]# kubectl delete -f create-deployment-service-clusterip.yaml
```

```powershell
输出
deployment.apps "nginx-apps" deleted 
service "nginx-apps" deleted
```

